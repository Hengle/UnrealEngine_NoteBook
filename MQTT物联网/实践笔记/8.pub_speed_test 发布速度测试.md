## MQTT实践
Paho C++示例 客户端应用 去完成一个简单的测试速度在哪个信息能发布

## 代码
```

#include <iostream>
#include <cstdlib>
#include <string>
#include <thread>
#include <future>						//功能模块
#include <atomic>						//原子操作
#include <chrono>
#include <cstring>
#include "mqtt/async_client.h"			//异步客户端
#include "mqtt/thread_queue.h"			//线程列队

using namespace std;
using namespace std::chrono;
//服务地址
const std::string DFLT_SERVER_ADDRESS { "tcp://localhost:1883" };
//载荷大小
const size_t	DFLT_PAYLOAD_SIZE = 1024;
//消息次数
const int		DFLT_N_MSG = 1000,
				DFLT_QOS = 1;
//主题{“test/speed”}
const string TOPIC {"test/speed"};

//载荷的字符指针 载荷 = “发布速度测试意外停止 ”
const char* LWT_PAYLOAD = "pub_speed_test died unexpectedly.";

// Queue for passing tokens to the wait thread
// 将令牌传递给等待线程的队列
mqtt::thread_queue<mqtt::delivery_token_ptr> que;

// Get the current time on the steady clock
// 获取当前时间在稳定的时钟之上
steady_clock::time_point now() { return steady_clock::now(); }

// Convert a duration to a count of milliseconds
// 将持续时间转换为毫秒数
template <class Rep, class Period>
int64_t msec(const std::chrono::duration<Rep, Period>& dur) {
	return (int64_t) duration_cast<milliseconds>(dur).count();
}

// --------------------------------------------------------------------------
// Thread function will wait for all the tokens to complete.
// Any exceptions thrown from here will be caught in main().
// 线程函数将等待所有令牌完成。
// 从这里抛出的任何异常都将在main()中捕获。

void token_wait_func()
{
	while (true) {
		//mqtt::提交凭证指针 凭证 = 列队获取
		mqtt::delivery_token_ptr tok = que.get();
		// 如果 凭证没了 就打断
		if (!tok) break;
		// 数目推送（“x”）
		//cout.put('x');
		// 凭证等待
		tok->wait();
	}
}

// --------------------------------------------------------------------------
// 主函数
int main(int argc, char* argv[])
{
	// 地址 = 命令行参数大于1时：第1个参数：默认值
	string	address  = (argc > 1) ? string(argv[1]) : DFLT_SERVER_ADDRESS;
	// 消息次数 = 命令行参数大于2时：第2个参数：默认值
	int		nMsg = (argc > 2) ? atoi(argv[2]) : DFLT_N_MSG;
	// 消息尺寸  = 命令行参数大于3时：第3个参数：默认值
	size_t	msgSz = (size_t) ((argc > 3) ? atol(argv[3]) : DFLT_PAYLOAD_SIZE);
	// 服务质量 = 命令行参数大于4时：第4个参数：默认值
	int		qos = (argc > 4) ? atoi(argv[4]) : DFLT_QOS;
	// 输出：初始化服务器：地址....
	cout << "Initializing for server '" << address << "'..." << flush;
	// 构建一个客户端（地址,""）
	mqtt::async_client cli(address, "");

	// mqtt；消息 将要发送的消息（主题，载荷，服务质量1，消息是否能被broker保存）
	mqtt::message willmsg(TOPIC, LWT_PAYLOAD, 1, true);
	// 持有管理遗嘱和遗嘱功能的选项集
	// mqtt::will_选项 will（will消息）
	mqtt::will_options will(willmsg);

	// mqtt::连接选项 连接选项
	mqtt::connect_options connOpts;
	//选项:清除会话
	connOpts.set_clean_session(true);
	//选项：设置will遗嘱（will遗嘱）
	connOpts.set_will(will);

	// Create a payload
	// 创建一个载荷
	mqtt::binary payload;
	// 消息尺寸遍历
	for (size_t i=0; i<msgSz; ++i)
		//载荷，在字符后面加
		payload.push_back('a' + i%26);
	// 输出：OK
	cout << "OK" << endl;

	try {
		// Create the message (move payload into it)
		// 创建消息（移动载荷到其中）
		// 消息 = mqtt::创建消息（主题，将消息移入（），服务质量，borker不保存）
		auto msg = mqtt::make_message(TOPIC, std::move(payload), qos, false);

		// Connect to the broker
		// 连接到broker
		cout << "\nConnecting..." << flush;
		// 记录起始时间
		auto start = now();
		// 客户端连接（连接选项）
		cli.connect(connOpts)->wait();
		// 结束时间
		auto end = now();
		// 输出：OK
		cout << "OK" << endl;
		// 输出：连接进入“毫秒（结束-开始）”ms
		cout << "Connected in " << msec(end - start) << "ms" << endl;
		//  fut = 异步（启动异步，token凭证等待函数）
		auto fut = std::async(launch::async, token_wait_func);

		// Publish the messages
		// 推送消息
		// 输出：推送（消息）信息....
		cout << "\nPublishing " << nMsg << " messages..." << flush;
		// 当前时间
		start = now();
		// 遍历消息次数
		for (int i=0; i<nMsg; ++i) {
			// 凭证 = 客户端.推送（信息）
			auto dtok = cli.publish(msg);
			//cout.put('^');
			// 列队put（把消息放到末端（凭证））
			que.put(std::move(dtok));
		}
		// 推送结束的时间
		auto pubend = now();
		// 列队.put(mqtt::发送凭证指针)
		que.put(mqtt::delivery_token_ptr());

		// Wait for all the tokens to complete
		// fut.获取
		fut.get();
		// 结束时间
		end = now();

		// 输出：OK
		cout << "OK" << endl;
		// ms = 毫秒（推送结束-开始）
		auto ms = msec(pubend - start);
		// 输出：推送（多少）ms（次数/毫秒）多少k 消息/每秒
		cout << "Published in    " << ms << "ms " << (nMsg/ms) << "k msg/sec" << endl;
		// ms = 毫秒（开始-结束）
		ms = msec(end - start);
		// 输出：承认在ms（次数/毫秒）多少k 消息/每秒
		cout << "Acknowledged in " << ms << "ms " << (nMsg/ms) << "k msg/sec" << endl;

		// Disconnect
		// 断开
		// 输出：断开连接
		cout << "\nDisconnecting..." << flush;
		// 开始时间
		start = now();
		// 客户端：断开连接（10秒）->等待完成（）
		cli.disconnect(seconds(10))->wait();
		// 结束时间
		end = now();
		// 输出：OK
		cout << "OK" << endl;
		// 输出： 断开在（多少毫秒）ms
		cout << "Disconnected in " << msec(end - start) << "ms" << endl;
	}
	// 抛出异常
	catch (const mqtt::exception& exc) {
		// 列队put（mqtt::交付凭证指针）
		que.put(mqtt::delivery_token_ptr{});
		//错误输出:错在哪里
		cerr << exc.what() << endl;
		return 1;
	}

 	return 0;
}

```