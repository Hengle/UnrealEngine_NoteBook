## MQTT实践
这个应用是一个MQTT订阅者 使用C++异步客户端
接口，使用回调去==接受消息==和==更新状态==

##### 示例
- 连接到MQTT服务器或者broker
- 订阅一个主题
- 通过回调API接受消息
- 接受==网络连接更新== 并且==尝试手动重连==
- 使用一个“清除会话‘ 并且 手动 重新订阅到主题 打开重连

```

#include <iostream>					//输入输出流
#include <cstdlib>					// C的库（命名空间）
#include <string>					// 字符串
#include <cstring>					// C的字符串
#include <cctype>					// C类型数据操作
#include <thread>					// 线程
#include <chrono>					// 时间操作
#include "mqtt/async_client.h"		// 导入mqtt的异步客户端

// 服务端地址
const std::string SERVER_ADDRESS("tcp://localhost:1883");
// 客户端ID
const std::string CLIENT_ID("paho_cpp_async_subcribe");
// 主题
const std::string TOPIC("hello");
// 服务质量
const int	QOS = 1;
// 重复尝试次数
const int	N_RETRY_ATTEMPTS = 5;

/////////////////////////////////////////////////////////////////////////////

// Callbacks for the success or failures of requested actions.
// 请求操作失败或成功 的  回调函数
// This could be used to initiate further action, but here we just log the
// results to the console.
// 这些将被用作初始化演示操作，但是 我们这 仅输出日志结果到控制台

// 操作监听器 : 继承自  mqtt::iaction_listener
class action_listener : public virtual mqtt::iaction_listener
{
	std::string name_;		// 名称

	// 启动失败
	void on_failure(const mqtt::token& tok) override {
		//输出 ： 名字 失败了
		std::cout << name_ << " failure";
		// 如果 请求令牌.获取消息id 有值
		if (tok.get_message_id() != 0)
			//输出： 令牌ID
			std::cout << " for token: [" << tok.get_message_id() << "]" << std::endl;
		std::cout << std::endl;
	}
	// 启动成功
	void on_success(const mqtt::token& tok) override {
		// 输出：name_成功令牌[ID]
		std::cout << name_ << " success";
		if (tok.get_message_id() != 0)
			std::cout << " for token: [" << tok.get_message_id() << "]" << std::endl;
		// tok获取主题
		auto top = tok.get_topics();
		// 主题或者主题不为空
		if (top && !top->empty())
			//输出 token的主题:从主题中解析到第一个元素
			std::cout << "\ttoken topic: '" << (*top)[0] << "', ..." << std::endl;
		std::cout << std::endl;
	}
	
public:
	// 公开构造函数（名称）
	action_listener(const std::string& name) : name_(name) {}
};

/////////////////////////////////////////////////////////////////////////////

/**
 * Local callback & listener class for use with the client connection.
 * 本地回调 和 监听类 用于客户端连接
 * This is primarily intended to receive messages, but it will also monitor
 * the connection to the broker. If the connection is lost, it will attempt
 * to restore the connection and re-subscribe to the topic.
 * 它的主要目的是 接受消息，但是它将检测连接到broker，它将尝试去恢复连接 并且 重新提交主题
 */

// 本地回调 继承自 mqtt::callback 和 mqtt::iaction_listener
class callback : public virtual mqtt::callback,
					public virtual mqtt::iaction_listener

{
	// Counter for the number of connection retries
	// 连接重试次数的计数器
	int nretry_;
	// The MQTT client
	// MQTT客户端
	mqtt::async_client& cli_;
	// Options to use if we need to reconnect
	// 如果我们需要重连的选项
	mqtt::connect_options& connOpts_;
	// An action listener to display the result of actions.
	// 一个操作监听器用于显示操作结果
	action_listener subListener_;

	// This deomonstrates manually reconnecting to the broker by calling
	// connect() again. This is a possibility for an application that keeps
	// a copy of it's original connect_options, or if the app wants to
	// reconnect with different options.
	// Another way this can be done manually, if using the same options, is
	// to just call the async_client::reconnect() method.
	// 这个说明手动的重新连接到broker通过呼叫重新连接。 这是一种拷贝应用原有连接选项的可能，或者这个应用想要用不同的选项重新连接。
	// 另外一种方式可以手动完成，如果使用同样的选项，这种方式 是 仅 call asyn_client::重连（） 方法

	// 重新连接
	void reconnect() {
		// std;;命名空间中的当前线程：：休眠（延时2500毫秒）
		std::this_thread::sleep_for(std::chrono::milliseconds(2500));
		try {
			//客户端连接（连接选项，空指针，this）
			cli_.connect(connOpts_, nullptr, *this);
		}
		//尝试失败 就丢出错误信息
		catch (const mqtt::exception& exc) {
			std::cerr << "Error: " << exc.what() << std::endl;
			exit(1);
		}
	}

	// Re-connection failure 重新连接失败
	// 启动失败 的重写（mqtt::令牌 ）
	void on_failure(const mqtt::token& tok) override {
		// 输出：连接尝试失败
		std::cout << "Connection attempt failed" << std::endl;
		// 重新连接次数 大于 最大重新连接次数时
		if (++nretry_ > N_RETRY_ATTEMPTS)
			//退出
			exit(1);
		// 重新连接
		reconnect();
	}

	// (Re)connection success
	// （重新)连接成功 的重写
	// Either this or connected() can be used for callbacks.
	// 要么连接成功 或者 连接 能被用作回调
	void on_success(const mqtt::token& tok) override {}

	// (Re)connection success
	// (重新)连接成功 的重写
	void connected(const std::string& cause) override {
		//输出： 连接成功
		//输出：订阅主题TOPIC 为客户端ID 使用 Qos 然后按下Q键退出
		std::cout << "\nConnection success" << std::endl;
		std::cout << "\nSubscribing to topic '" << TOPIC << "'\n"
			<< "\tfor client " << CLIENT_ID
			<< " using QoS" << QOS << "\n"
			<< "\nPress Q<Enter> to quit\n" << std::endl;

		cli_.subscribe(TOPIC, QOS, nullptr, subListener_);
	}

	// Callback for when the connection is lost.
	// This will initiate the attempt to manually reconnect.
	// 当连接失败的回调函数
	// 这个将会初始化 尝试手动重连

	// 连接丢失（） 覆盖
	void connection_lost(const std::string& cause) override {
		// 输出：连接丢失
		std::cout << "\nConnection lost" << std::endl;
		// 如果原因 不为空
		if (!cause.empty())
			// 输出：断开连接的原因
			std::cout << "\tcause: " << cause << std::endl;
		//输出：重连
		std::cout << "Reconnecting..." << std::endl;
		//重置：重新连接次数
		nretry_ = 0;
		//重新连接
		reconnect();
	}

	// Callback for when a message arrives.
	// 当一个消息抵达的 回调
	// 写虚函数的优点是：让函数可以在库中的一些函数操作中，
	// 这里比如（连接或者连接失败这类我们不会重新写，但是调用的时候需要有回调的函数，这样我们可以重新定义）
	// 回调的另一优势是你不知道什么时候会要调用，
	// 但是程序执行到某种状态时就得返回程序的某种特殊状态，或者实现一些后续的功能

	//消息抵达的回调（参数： mqtt的消息指针 ）
	void message_arrived(mqtt::const_message_ptr msg) override {
		// 输出：消息已经抵达 主题：Topic 消息：msg消息
		std::cout << "Message arrived" << std::endl;
		std::cout << "\ttopic: '" << msg->get_topic() << "'" << std::endl;
		std::cout << "\tpayload: '" << msg->to_string() << "'\n" << std::endl;
	}
	// 交付完成（） 覆盖
	void delivery_complete(mqtt::delivery_token_ptr token) override {}

public:
	// 回调的重构（需要： mqtt的客户端、连接选项）重试次数_、连接选项_、子监听（”下标“）
	callback(mqtt::async_client& cli, mqtt::connect_options& connOpts)
				: nretry_(0), cli_(cli), connOpts_(connOpts), subListener_("Subscription") {}
};

/////////////////////////////////////////////////////////////////////////////

// 主程序
int main(int argc, char* argv[])
{
	// A subscriber often wants the server to remember its messages when its
	// disconnected. In that case, it needs a unique ClientID and a
	// non-clean session.
	// 一个"订阅者"经常想要 在断连的时候 服务器去记住它的消息
	// 在那些示例中，它需要一个独特的 客户端ID 并且 一个不干净的会话

	//构建一个 客户端对象
	mqtt::async_client cli(SERVER_ADDRESS, CLIENT_ID);
	//创建一个 连接选项对象
	mqtt::connect_options connOpts;
	//对连接选项的 clean_session变量进行设置（假）
	connOpts.set_clean_session(false);

	// Install the callback(s) before connecting.
	// 在连接之前 安装回调 ：这里就是创建一个 （回调对象）
	callback cb(cli, connOpts);

	// 客户端设置 回调
	cli.set_callback(cb);

	// Start the connection.
	// When completed, the callback will subscribe to topic.
	// 开始连接
	// 当完成，这个回调将会”订阅“到主题
	try {
		// 输出： 连接到MQTT服务器
		std::cout << "Connecting to the MQTT server..." << std::flush;
		// 客户端.连接（连接选项，空指针，回调）
		cli.connect(connOpts, nullptr, cb);
	}
	// 丢出报错信息（防止崩溃，并且返回有效的报错信息）
	catch (const mqtt::exception& exc) {
		std::cerr << "\nERROR: Unable to connect to MQTT server: '"
			<< SERVER_ADDRESS << "'" << exc << std::endl;
		return 1;
	}

	// Just block till user tells us to quit.
	// 只是阻止，直到用户告诉我们退出。

	while (std::tolower(std::cin.get()) != 'q')
		;

	// Disconnect
	// 断开连接
	try {
		// 输出：断连从MQTT服务器
		std::cout << "\nDisconnecting from the MQTT server..." << std::flush;
		// 客户端断开连接（） - 等待（）
		cli.disconnect()->wait();
		// 输出：OK
		std::cout << "OK" << std::endl;
	}
	// 输出;断开连接时的报错信息
	catch (const mqtt::exception& exc) {
		std::cerr << exc << std::endl;
		return 1;
	}

 	return 0;
}

```

