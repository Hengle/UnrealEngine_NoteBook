## MQTT实践
“聊天”应用程序实际上是消息传递系统的“Hello World”应用程序。
这允许用户输入要发送到“组”的消息，同时查看组中其他成员发送的所有消息。

这个应用是一个MQTT 发布者/订阅者 使用C++ 异步客户端，使用回调去接收消息并且状态更新。

示例内容：
- 连接到一个MQTT 服务器或者broker（代理）
- 发布消息
- 订阅消息
- 接受消息（回调）通过一个lambda函数

用法：
```
mqttpp_chat<user><group>  
```

###### 代码部分
```

#include <iostream>					// 输入输出
#include <cstdlib>					// C的命名空间
#include <string>					// 字符串
#include <cstring>					// C类型字符串
#include <cctype>					// C类型相关操作
#include <thread>					// 线程库
#include <chrono>					// 时间库
#include "mqtt/async_client.h"		//异步客户端
#include "mqtt/topic.h"				//主题

/////////////////////////////////////////////////////////////////////////////
 // 主程序
int main(int argc, char* argv[])
{
	// The broker/server address
	// broker代理/服务器 地址  
	const std::string SERVER_ADDRESS("tcp://localhost:1883");

	// The QoS to use for publishing and subscribing
	// QOS 服务质量 同于 发布或者订阅
	const int QOS = 1;

	// Tell the broker we don't want our own messages sent back to us.
	// 告诉 broker代理“我们不想要我们的消息返回到我们”
	const bool NO_LOCAL = true;
	// 如果命令行参数 不等于3  
	if (argc != 3) {
		// 输出：用户：mqttpp_对话《用户》《组件》
		std::cout << "USAGE: mqttpp_chat <user> <group>" << std::endl;
		return 1;
	}
	// 对话用户{命令行参数1} 对话组{命令行参数2} 对话主题{聊天+聊天组}
	std::string chatUser  { argv[1] },
				chatGroup { argv[2] },
				chatTopic { "chat/"+chatGroup };

	// LWT message is broadcast to other users if out connection is lost
	// LWT最后消息（遗嘱） 是广播 到其他用户 如果 外部连接 已经丢失
	auto lwt = mqtt::message(chatTopic, "<<<"+chatUser+" was disconnected>>>", QOS, false);

	// Set up the connect options
	// mqtt属性 连接属性
	mqtt::properties connectProperties{
		//mqtt参数::会话到期时间间隔，604800
		{mqtt::property::SESSION_EXPIRY_INTERVAL, 604800}
    };

	// 连接选项 = mqtt：：连接选项构建器（）
	//			.mqtt版本（MQTTVERSION_5），参数（连接参数），启动时清除（真），
	//			will（移除lwt）,保持激活的间隔（20秒），完结（）
	auto connOpts = mqtt::connect_options_builder()
		.mqtt_version(MQTTVERSION_5)
		.properties(connectProperties)
		.clean_start(true)
		.will(std::move(lwt))
		.keep_alive_interval(std::chrono::seconds(20))
		.finalize();

	// 异步客户端 cli（服务地址，"",创建选项（版本5））
	mqtt::async_client cli(SERVER_ADDRESS, "",
						   mqtt::create_options(MQTTVERSION_5));

	// Set a callback for connection lost.
	// This just exits the app.

	// 设置一个连接丢失的回调，用的是lambda
	cli.set_connection_lost_handler([](const std::string&) {
		//输出：连接丢失
		std::cout << "*** Connection Lost  ***" << std::endl;
		exit(2);
	});

	// Set the callback for incoming messages
	// 设置 输入信息的回调

	//客户端.设置消息回调（mqtt::消息指针）
	cli.set_message_callback([](mqtt::const_message_ptr msg) {
		//输出:消息指针中读取字符串
		std::cout << msg->get_payload_str() << std::endl;
	});

	// We publish and subscribe to one topic,
	// so a 'topic' object is helpful.
	// 我们发布并且订阅到一个主题
	// 因此一个主题对象是有帮助的

	// mqtt主题 主题（客户端，‘聊天’+聊天组，服务质量）
	mqtt::topic topic { cli, "chat/"+chatGroup, QOS };

	// Start the connection.

	try {
		// 输出：连接到聊天服务器在+ 服务端地址+....
		// std::flush是刷新缓冲区
		std::cout << "Connecting to the chat server at '" << SERVER_ADDRESS
			<< "'..." << std::flush;
		// 标签 = cli.连接（连接选项）
		auto tok = cli.connect(connOpts);
		// 标签 等待
		tok->wait();

		// Subscribe to the topic using "no local" so that
		// we don't get own messages sent back to us
		// 订阅到主题使用“非本地” 因此 我们不会获取我们的消息发送回到我们

		// 输出：OK 加入到组中.....
		std::cout << "Ok\nJoining the group..." << std::flush;
		// 订阅对象 = 订阅选项（没有本地）
		auto subOpts = mqtt::subscribe_options(NO_LOCAL);
		// 主题订阅（订阅选项）等待（）
		topic.subscribe(subOpts)->wait();
		// 输出：OK
		std::cout << "Ok" << std::endl;
	}
	// mqtt的报错信息
	catch (const mqtt::exception& exc) {
		// 输出：报错信息
		std::cerr << "\nERROR: Unable to connect. "
			<< exc.what() << std::endl;
		return 1;
	}

	// Let eveyone know that a new user joined the conversation.
	// 让所有人都知道 一个新的用户加入到谈话

	topic.publish("<<" + chatUser + " joined the group>>");

	// Read messages from the console and publish them.
	// Quit when the use enters an empty line.
	// 读取消息从控制台 并且 发布他们
	// 推出 当 用户进入一个空的行

	// 用户消息
	std::string usrMsg;

	// 当（获取行(输入的用户消息)或者用户消息不为空）
	while (std::getline(std::cin, usrMsg) && !usrMsg.empty()) {
		//用户消息 = 用户聊天+：+用户消息
		usrMsg = chatUser + ": " + usrMsg;
		//主题：发布消息
		topic.publish(usrMsg);
	}

	// Let eveyone know that the user left the conversation.
	// 让每个人都知道用户离开了对话

	// 话题.发布（《用户聊天 剩余的组》）
	topic.publish("<<" + chatUser + " left the group>>")->wait();

	// Disconnect
	// 断开连接
	try {
		//输出：断开连接从聊天服务器
		std::cout << "Disconnecting from the chat server..." << std::flush;
		//客户端断开连接
		cli.disconnect()->wait();
		// 输出：OK
		std::cout << "OK" << std::endl;
	}
	// 输出：错误信息
	catch (const mqtt::exception& exc) {
		std::cerr << exc.what() << std::endl;
		return 1;
	}

 	return 0;
}
```






