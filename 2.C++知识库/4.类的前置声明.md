**一、类嵌套的疑问**

```ad-note
title:问题的源头（内的相互包含）
C++头文件重复包含实在是一个令人头痛的问题，假设我们有两个类A和B，分别定义在各自的头文件A.h和B.h中，但是在A中要用到B，B中也要用到A，但是这样的写法当然是错误的：
```

错误示范一：
```C++
class B; //前置声明
class A
{
public:
      B b;   // 这里就存在一个问题我们不知道B的大小，里面包含了哪些数据成员 
};

class B
{
public:
	  A a;  
};
```


> 关键的原因：就是我们不知道对象的大小，却要创建一个对象这是行不通的。然而在特定的平台上，指针的大小是确定的。

因为在A对象中要开辟一块属于B的空间，而B中又有A的空间，是一个逻辑错误，无法实现的,在这里我们只需要把其中的一个A类中的B类型成员改成指针形式就可以避免这个无限延伸的怪圈了,为什么要更改A而不是B？因为就算你在B中做了类似的动作，也仍然会编译错误，表面上这仅仅上一个先后顺序的问题

为什么会这样呢？`因为C++编译器自上而下编译源文件的时候，对每一个数据的定义，总是需要知道定义的数据类型的大小`。在预先声明语句class B;之后，编译器已经知道B是一个类，但是其中的数据却是未知的，因此B类型的大小也不知道，这样就造成了编译失败，VC++6.0下会得到如下编译错误：

      error C2079: 'b' uses undefined class 'B'

`将A中的b更改为B指针类型之后，由于在特定的平台上，指针所占的空间是一定的（在Win32平台上是4字节），这样可以通过编译`


**二、不同头文件中的类的嵌套**

在实际编程中，不同的类一般是放在不同的相互独立的头文件中的，这样两个类在相互引用时又会有不一样的问题,重复编译是问题出现的根本原因。为了保证头文件仅被编译一次，在C++中常用的办法是使用条件编译命令在头文件中我们常常会看到以下语句段（以VC++6.0自动生成的头文件为例）：

```C++
#IFNDEF  TESTSTR
#define TESTSTR

      //很多语句

#endif
```

意思是如果没有定义过这个宏，那么就定义它，然后执行直到#endif的所有语句如果下次在与要这段代码，由于已经定义了那个宏，因此重复的代码不会被再次执行这实在是一个巧妙而高效的办法在高版本的VC++上，还可以使用这个命令来代替以上的所有：

      #pragma once
它的意思是，本文件内的代码只被使用一次

但是不要以为使用了这种机制就全部搞定了，比如在以下的代码中：

错误示范
```C++
//文件A.h中的代码
#pragma once
#include "B.h"
class A{

      public:

          B* b;

};

//文件B.h中的代码
#pragma once
#include "A.h"
class B{
      public:
          A* a;
};
```

这里两者都使用了指针成员，因此嵌套本身不会有什么问题，在主函数前面使用#include "A.h"之后，主要编译错误如下：

      error C2501: 'A' : missing storage-class or type specifiers

仍然是类型不能找到的错误。其实这里仍然需要前置声明，分别添加前置声明之后，可以成功编译了。代码形式如下：

```C++
//文件A.h中的代码
#pragma once
#include "B.h"
class B;
class A{
      public:
          B* b;
};

//文件B.h中的代码
#pragma once
#include "A.h"
class A;
class B{
      public:
          A* a;
};
```

这样至少可以说明，头文件包含代替不了前置声明,有的时候只能依靠前置声明来解决问题,我们还要思考一下，有了前置声明的时候头文件包含还是必要的吗？我们尝试去掉A.h和B.h中的#include行，发现没有出现新的错误那么究竟什么时候需要前置声明，什么时候需要头文件包含呢？

**三、两点原则**

头文件包含其实是一想很烦琐的工作，不但我们看着累，编译器编译的时候也很累，再加上头文件中常常出现的宏定义感觉各种宏定义的展开是非常耗时间的，远不如自定义函数来得速度我仅就不同头文件源文件间的句则结构问题提出两点原则，仅供参考：

第一个原则: `如果可以不包含头文件，那就不要包含`,这时候前置声明可以解决问题,如果使用的仅仅是一个类的指针，没有使用这个类的具体对象（非指针），也没有访问到类的具体成员，那么前置声明就可以了,因为指针这一数据类型的大小是特定的，编译器可以获知.

第二个原则: `尽量在CPP文件中包含头文件，而不要在头文件中包含。`假设类A的一个成员是一个指向类B的指针，在类A的头文件中使用了类B的前置声明，那么在A的实现中我们需要访问B的具体成员，因此需要包含头文件，那么我们应该在类A的实现部分(CPP文件)包含类B的头文件而非声明部分(H文件)。


**四、C++的前置声明**

刚开始学习c++的人都会遇到这样的问题：

定义一个类 class A，这个类里面使用了类B的对象b，然后定义了一个类B，里面也包含了一个类A的对象a，就成了这样：

错误示例：
```C++
//a.h  
#include "b.h"  
class A  
{  
....  
private:  
     B b;  
};  
//b.h  
#include "a.h"  
class B  
{  
....  
private:  
    A a;  
};
```

一编译，就出现了一个互包含的问题了，这时就有人跳出来说，这个问题的解决办法可以这样，在a.h文件中声明类B，然后使用B的指针。

```C++
//a.h   
//#include "b.h"  
class B;   //就是在这里 其实这里就是想到于定义一个类型，方便的找到了类型
class A   
{  
	....   
private:  
	 B *b;   
};   
//b.h   
#include "a.h"   
class B  
{  
	....   
private:  
	 A a;   
};
```

然后，问题就解决了。
但是，有人知道问题是为什么就被解决的吗，也就是说，加了个前置声明为什么就解决了这样的问题。下面，让我来探讨一下这个前置声明。
类的前置声明是有许多的好处的。

我们使用前置声明的一个好处是，从上面看到，当我们在类A使用类B的前置声明时，我们修改类B时，只需要重新编译类B，而不需要重新编译a.h的（当然，在真正使用类B时，必须包含b.h）。

另外一个好处是`减小类A的大小`，上面的代码没有体现，那么我们来看下：
```C++
 //a.h  
class B;  
class A  
{  
....  
private:  
	B *b;  
....  
};  
//b.h  
class B  
{  
....  
private:  
	int a;  
	int b;  
	int c;  
};
```

class A;
是一种不完整的声明，只要类B中没有执行需要了解类A的大小或者成员的操作，则这样的不完整声明允许声明指向A的指针和引用。

```ad-note
title:总结
首先，我们为什么要包括头文件？问题的回答很简单，通常是我们需要获得某个类型的定义(definition)。那么接下来的问题就是，在什么情况下我们才需要类型的定义，在什么情况下我们只需要声明就足够了？问题的回答是当我们需要知道这个`类型的大小`或者需要`知道它的函数签名`的时候，我们就需要获得它的定义。
```
